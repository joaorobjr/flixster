---
title: "A movies recommender system using Flixster data"
subtitle: "Practical assignment of Advanced Topics in Data Science/Data Mining II"
author: "By Robson Teixeira and Nuno Gomes"
date: "M:DS -- FCUP, 17/05/2020"
output:
  bookdown::html_document2:
    code_folding: "hide"
    df_print: tibble
    fig_caption: yes
    includes:
      in_header: header.html
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
  bookdown::pdf_document2:
    #citation_package: natbib
    df_print: tibble
    fig_caption: yes
    fig_crop: no
    fig_height: 5
    fig_width: 7
    number_sections: yes
    toc: yes
geometry:
- top=25mm
- bottom=25mm
- left=25mm
- right=20mm
- heightrounded
header-includes:
  \usepackage{caption}
  \usepackage{fancyhdr}
  \usepackage{lmodern}
  \usepackage[detect-all]{siunitx}
highlight-style: pygments
linkcolor: blue
mainfont: Source Variable Pro
fontsize: 12pt
sansfont: Source Sans Pro
documentclass: report
urlcolor: blue
references:
  
- id: netflix2009
  title: The Netflix Prize
  URL: https://www.netflixprize.com/
  issued:
    year: 2009
- id: fenner2012
  title: One-click science marketing
  author:
  - family: Fenner
    given: Martin
  container-title: Nature Materials
  volume: 11
  URL: 'http://dx.doi.org/10.1038/nmat3283'
  DOI: 10.1038/nmat3283
  issue: 4
  publisher: Nature Publishing Group
  page: 261-263
  type: article-journal
  issued:
    year: 2012
    month: 3
---

```{r setup, include= F}
knitr::opts_chunk$set(echo= T)
require(arules)
require(arulesSequences)
require(arulesViz)
require(caret)
require(dplyr)
require(e1071)
require(forcats)
require(funModeling)
require(Hmisc)
require(igraph)
require(plotrix)
require(recommenderlab)
require(stringr)
require(text2vec)
require(tidyverse)
require(tm)

#if(!require(tidyverse)) 
#  install.packages("tidyverse", repos = "http://cran.us.r-project.org")
#if(!require(funModeling)) 
#  install.packages("funModeling", repos = "http://cran.us.r-project.org")
#if(!require(caret)) 
#  install.packages("caret", repos = "http://cran.us.r-project.org")
#if(!require(Hmisc)) 
#  install.packages("Hmisc", repos = "http://cran.us.r-project.org")
#if(!require(ggplot2)) 
#  install.packages("ggplot2", repos = "http://cran.us.r-project.org")


options(scipen= 999) # turns off scientific notation; to turn it back on, use scipen= 0
```
# Abstract {-}
We report on the methodology we adopted to create a recommendation system for films using the Flixster data set, and on the results we obtained.
Our model is based on the assumption that if a group of users had liked the same films in the past, they will like similar movies in the future.
Hence, if two users have a similar rating history (movies and ratings) and one of them has recently enjoyed a film that the other has not seen yet, then that movie is proposed to the latter.
The recommendation system uniquely takes into account the user ratings, and does not consider the characteristics of the films.
ADD MAIN RESULTS HERE.

# Introduction
**Recommender** or **recommendation** systems are a branch of *Web usage mining* that aim at predicting the "preferences" or the "rating" a user would give to an item.
They are widely used on the Web, mainly in online streaming services, such as YouTube, Amazon, or Netflix (just to name a few), and e-commerce applications (eBay, Amazon, OLX, *etc.*), in order to recommend products and services to the users.
They serve three important functions: (*i*) to increase the profit of companies, (*ii*) to help users to select specific products within the available offer, by giving them personalised recommendations based on previous interactions, and (*iii*) to predict the rating for a new item.
Companies struggle for customer loyalty on a daily basis, and while doing so, they invest on recommender systems that try to increase the likelihood of purchase, by analysing customers' preferences and past interactions.

The importance of recommender systems on the success of businesses and on company-customer relationships can be inferred from the one million dollar prize that Netflix offered in 2006 to the person or team that could improve their recommendation system by at least $10\,\%$ [@netflix2009].
The success of companies such as Amazon or platforms like Youtube lies partly in the recommendation and marketing strategies, based on the user preferences.

During this project, we created a film recommendation system using the Flixster data set, while applying the knowledge acquired in the course of Advanced Topics in Data Science/Data Mining II over the second semestre of the Masters in Data Science.

This report is organised as follows: 

# The Flixster data set
Flixster was an American social-networking online service founded by Joe Greenstein and Sarah Chari in 2006.
The platform allowed users to learn about films, to watch trailers, to share their ratings of movies, to discover new films based on their tastes and past views, and to know and meet other users with similar tastes in films.
The company was bought by Fandango in 2016, and the website was shut down in February 2018 in the USA, and October 2019 internationally. 

```{r data, echo= F, error= F, warning= F}
movies.orig= read.delim("../data/movie-names.txt")
profiles.orig= read.csv(
  "../data/profile.txt",
  skipNul= T,
  na.strings= c("N/A", "")
)
ratings.orig= read.delim(
  "../data/ratings.timed.txt",
  sep= "\t",
  skipNul= T,
  col.names= c("userid", "movieid", "rating", "date")
)

```

The data set used in this study was provided by the Flisxter website, and it can still be found online.^[https://sites.google.com/view/mohsenjamali/flixter-data-set]
It consists of $\num{8196077}$ ratings of $\num{48794}$ films by $\num{147612}$ users.
The data are distributed in three files: 

* **movie-names.txt** --- a file containing a collection of \num{66720} film titles and corresponding identification tags;

* **profile.txt** --- a file with \num{1002796} instances, containing general information regarding the users, including user id, gender, age, location, for how long the user has been a member, and the code tags for the last login and the profile view;

* **Ratings.time.txt** --- the aforementioned data set, with \num{8196077} ratings, including the user ID, the movie ID, and the date the rating was registered.

The three data files were loaded into the variables `movies`, `profiles`, and `ratings`, respectively.
A summary of the structure of each of them and a glimpse of their first rows is presented in what follows.

```{r movies_summary, warning= F, error= F, echo= F}
glimpse(movies.orig)
df_status(movies.orig)
head(movies.orig)
```
The previous output represents a glimpse of the `movies` *tibble*, which contains $\num{66730}$ records and two variables (`moviename` and `movieid`) of character and integer types, respectively.
The table contains $\num{66730}$ unique values, with no zeros, no "not availables" (NAs), nor infinites.
In its original form, the `moviename` variable contains html code, which was subsequently removed (see section \@ref(data-cleaning)).

```{r profiles_summary, warning= F, error= F, echo= F}
glimpse(profiles.orig)
df_status(profiles.orig)
head(profiles.orig)
```
The output above highlights the `profiles` tibble, with $\num{1002796}$ records and seven variables: the type-integer `userid`, `location`, and `lastlogin`, and the type-character `gender`, `memberfor`, `profileview`, and `age`).
Zeros and NAs are present in some variables---`location` or `age`, for example---but there are no infinite values.
The time tag in the `memberfor` variable was removed (see section \@ref(data-cleaning)) for being always equal to 00:00:00.

```{r ratings_summary, warning= F, error= F, echo= F}
glimpse(ratings.orig)
df_status(ratings.orig)
head(ratings.orig)
```
Above, the `ratings` tibble, with $\num{8196077}$ instances and four variables (`userid`, `movieid`, `rating`, and `date`).
Similarly to the previous case, the time tag in `date` was removed (section \@ref(data-cleaning)).

Table \@ref(tab:variables) describes all variables contained in the three original tables of the data set.
Clearly, the type of some of variables is incorrect and inconvenient for analysis---`age`, `date`, and `gender`, just to name a few---and that was taken care of in section \@ref(data-cleaning).

Table: (\#tab:variables) List of variables present in the three original files from the Flixster data set.

Variable    |Type        |Description                   |Tibble
------------|------------|------------------------------|------
age         |character   |Age of user                   |profiles
date        |character   |Date in which user rated movie|ratings
gender      |character   |User gender                   |profiles
lastlogin   |integer     |Last login numerical tag      |profiles
location    |integer     |Location identifier of user   |profiles
memberfor   |character   |Member since date             |profiles
movieid     |integer     |Movie unique identifier       |movies
movieid     |integer     |Movie unique identifier       |ratings
moviename   |character   |movie name                    |movies
profileview |character   |Numerical tag of the user     |profiles
rating      |double      |Rating of movie by user       |ratings
userid      |integer     |User unique identifier        |profiles
userid      |integer     |User unique identifier        |ratings


# Exploratory data analysis and engineering {#edae}
The creation of a recomendation system requires the identification of the most important features involved in the prediction of the ratings.
With that goal in mind, we cleaned the data (section \@ref(data-cleaning)) and analysed statistically the variables (section \@ref(eda)) to understand them and the relationships between them.

Since **R** does not have a base function to calculate the mode, we created one, the `getmode` function.
It was useful in our statistical analysis and in the imputation of values in some of the variables.

```{r eval= F}
# compute the mode
getmode= function(arr) {
  uniq.vals= unique(arr)
  uniq.vals[which.max(tabulate(match(arr, uniq.vals)))]
}

```

```{r}
movies.raw= data.frame(movies.orig)
profiles.raw= data.frame(profiles.orig)
ratings.raw= data.frame(ratings.orig)
```

## Data cleaning {#data-cleaning}
We started by removing the time tag from the variables `date` and `memberfor`, as it was always equal to 00:00:00 and, thus, irrelevant for our analysis.

```{r}
ratings.raw$date= ratings.raw$date %>% str_replace(" 00:00:00", "")
profiles.raw$memberfor= profiles.raw$memberfor %>% str_replace(" 00:00:00", "")
```

Then, we converted the variables `age` and `provileview` to integers, `gender` to a factor, and `memberfor` and `date` to dates.
```{r, warning= F}
profiles.raw$age= as.integer(profiles.raw$age)
profiles.raw$profileview= as.integer(profiles.raw$profileview)
profiles.raw$gender= as.factor(profiles.raw$gender)
profiles.raw$memberfor= as.Date(profiles.raw$memberfor)
ratings.raw$date= as.Date(ratings.raw$date)
```

Several movie included strange characters in their names due to badly or poorly rendered ASCII codes.
Those were identified and replaced.
```{r}
movies.raw$moviename= movies.raw$moviename %>%
  str_replace_all("&#233;", "é")
movies.raw$moviename= movies.raw$moviename %>%
  str_replace_all("&amp;", "&")
movies.raw$moviename= movies.raw$moviename %>%
  str_replace_all("&#\\d*;", "")

```

Finally, for the sake of personal taste and convenience, we converted the three main tables into tibbles.
```{r}
movies= tbl_df(movies.raw)
profiles= tbl_df(profiles.raw)
ratings= tbl_df(ratings.raw)
```
A quick inspection allowed us to conclude that the `profilesview` and `age` variables were the same.
So, we decided to remove the former right away, even before a more in depth exploratory data analysis.
```{r}
profiles= profiles %>% select(-"profileview")
```

Below is a summary of the three tables---respectively `movies`, `profiles`, and `ratings`---as they stood after the preliminary cleaning of the variables.
```{r}
movies
profiles
ratings
```

## Statistical exploration of the variables {#eda}
All features contained in the three tibbles (`movies`, `profiles`, and `ratings`) were saved in standalone variables, to facilitate their statistical analysis.
Those variables are described in tab. \@ref(tab:variables-standalone).
It is worth noting that during the creation of the `gender` variable, all NAs were assigned the category "Other".

Table: (\#tab:variables-standalone) List of standalone variables created from the original features present in the three files from the Flixster data set, after type correction and preliminary data engineering.

Variable        |Type        |Description                   |Tibble
----------------|------------|------------------------------|------
age             |integer     |Age of user                   |profiles
dates           |date        |Date in which user rated movie|ratings
gender          |factor      |Gender of the user (*Female*, *Male*, and *Other*) |profiles
lastlogin       |integer     |Last login numerical tag      |profiles
location        |integer     |Location identifier of user   |profiles
memberfor       |date        |Member since date             |profiles
movieid.movies  |integer     |Movie unique identifier       |movies
movieid.ratings |integer     |Movie unique identifier       |ratings
moviename       |character   |movie name                    |movies
profileview     |integer     |Numerical tag of the user     |profiles
rating          |double      |Rating of movie by user       |ratings
userid.profiles |integer     |User unique identifier        |profiles
userid.ratings  |integer     |User unique identifier        |ratings



```{r}
age= profiles$age
dates= ratings$date
gender= fct_explicit_na(profiles$gender, "Other")
lastlogin= profiles$lastlogin
location= profiles$location
memberfor= profiles$memberfor #
movieid.movies= movies$movieid
movieid.ratings= ratings$movieid
moviename= movies$moviename
rating= ratings$rating
userid.profiles= profiles$userid
userid.ratings= ratings$userid
```

Understanding the structure of the data, the distribution of the variables, and the relationships between them is fundamental to build a solid model.
We therefore analysed each of the features present in tab. \@ref(tab:variables).

### Age
The variable `age` has a minimum of 12 years, a maximum of 113 years, and a median of 25 years.
The maximum is clearly an outlier.
The variable also contains more than $\num{255000}$ NAs, corresponding to approximately $25.5\,\%$ of all age values.
```{r}
summary(age) # min= 12; max= 113; NAs= 255618
idx.nas.age= which(is.na(age)) # 25.5% of all age values
```

Removing the NAs, we obtain a variance of $\num{107.5}$ years.
```{r}
age.clean= na.omit(age)
var(age.clean) # 107.5378
```
The skeweness is positive, indicating a right-skewed distribution.
```{r}
skewness(age.clean) # 2.444335
```

We plotted the histogram and the boxplot of `ages` (fig. \@ref(fig:age-outliers)).
```{r age-outliers, fig.cap= "\\label{fig:age-outliers}Histogram (*left*) and boxplot (*right*) of the `age` variable. The distribution is right skewed and exihibits several outliers."}
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(age.clean,
  breaks= seq(round(min(age.clean)) - 1, round(max(age.clean)) + 1, by= 1),
  xlab= "Age (yrs)"
)
boxplot(age.clean,
  yaxt= "n",
  main= "Boxplot of age"
)
axis(2, las= 2)
```

Most of the individuals are between 18 and 30 years old, corresponding to more than $\num{250000}$ of Flixster's users.
The histogram highlights the right skeweness of the distribution.
This is expected, since Flixster's customers were typically young.

We also plotted the histogram of `age` as a function of `gender` (fig. \@ref(fig:histo-age-gender)).
The vertical dashed lines represent respectively the first and 99.5^{th} percentile of the distribution of ages.

```{r histo-age-gender, fig.align= "center", fig.cap= "\\label{histo-age-gender}Histogram of the age of users as a function of their gender. The majority of Flixster users are women and men, with the first and 99.5^{th} percentile between 14 and 70 years old."}
percentile.age= quantile(age, c(0.01, 0.9951), na.rm= T)
dfp.age=data.frame(value= percentile.age, percentile= c("1st", "99.5th"))
ggplot(data.frame(age= age, gender= gender)) +
  geom_histogram(
    aes(x= age, fill= gender),
    stat= "count",
    position= "dodge"
  ) +
  labs(x= "Age (yrs)", y= "Total", 
       title= "Distribuition of users per age and gender"#, 
#       subtitle= "(right skewed distribution)"
  ) +
  geom_vline(
    data= dfp.age,
    aes(xintercept= value, colour= percentile),
    show.legend= T,
    linetype= "dashed") +
  theme_bw()
rm(percentile.age, dfp.age)
```

Ages bellow 14 and above 70 would be safe to be considered as outliers.
However, we only removed users with ages above 70 years old, the set of which corresponded to $0.5\,\%$ of all ages.
The histogram and boxplot of `ages` without outliers is represented in fig. \@ref(fig:age-no-outliers).

```{r}
age.out= boxplot.stats(age.clean, coef= 3.9)$out
age.no.out.idx= !(age.clean %in% age.out)
age.no.out= age.clean[age.no.out.idx]
summary(age.no.out) # max= 71 (99.5% of values)
```

```{r age-no-outliers, fig.cap= "\\label{age-no-outliers}Histogram (*left*) and boxplot (*right*) of `ages` after removing the outliers."}
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(age.no.out,
  breaks= seq(round(min(age.no.out)) - 1, round(max(age.no.out)) + 1, by= 1),
  xlab= "Age (yrs)",
  main= "Histogram of age"
)
boxplot(age.no.out, outline= F, yaxt= "n")
axis(2, las= 2)
mtext(
  side= 3, line= 2, at= 1, cex= 1.2,
  expression(paste("Boxplot of age"))
)
mtext(side= 3, line= 1, at= 1, cex= 0.7, "Outliers removed")
```

### Dates and Memberfor
We detected several incorrect dates in the data set, both in the `date` and in `memberfor`, respectively from the `ratings` and the `profiles` tibbles.
Those dates were either before the founding of Flixster (2006/01/20) or NA values---we detected dates as early as 1900/01/01 for `memberfor` and 1941/12/07 for `dates`, and 203 NAs in `memberfor` (no NAs in `dates`).
Regarding the NAs in `memberfor`, we simply removed the corresponding instances, since, on the one hand the total number of NAs was small, corresponding to $0.02\,\%$ of the total number of values, and, on the other hand, there was no way of estimating a reasonable date.
For the remainder of the wrong dates, we performed imputation, according to the following rules: (*i*) we made `memberfor` equal to the minimum rating date every time the former was after the latter, *i.e.*, when the membership date was after the first rating, and (*ii*) we replaced all dates before 2006/01/20 by Fixster's founding date.
We ended up with two arrays with dates between 2006/01/20 and 2009/11/17 (`dates` case) and 2009/12/03 (`memberfor` case), with no NAs.

```{r}
date.flixster= as.Date("2006-01-20")
idx.memberfor.wrong= which(profiles$memberfor < date.flixster) # 57722
profiles$memberfor[idx.memberfor.wrong]= date.flixster
memberfor= profiles$memberfor
idx.nas.memberfor= which(is.na(memberfor)) # 203
uids.memberfor.nas= profiles$userid[idx.nas.memberfor] # 203
```


```{r eval= F}
# fill in NAs in memberfor with earliest rating date
# join profiles and ratings tables
users.ratings= tbl_df(merge(profiles, ratings, by= "userid"))
for (i in 1:nrow(users.ratings)) {
  if (is.na(users.ratings$memberfor[i])) {
    users.ratings$memberfor[i]= users.ratings$date[i]
  }
}
write.csv(users.ratings, file= '../data/users-ratings.csv')
users.ratings= read.csv("../data/users-ratings.csv")
memberfor= as.Date(users.ratings$memberfor)
summary(memberfor)
write.csv(memberfor, "../data/memberfor.csv")
```

```{r}
tmp= read.csv("../data/memberfor.csv")
memberfor= as.Date(tmp$x)
```

```{r}
idx.date.wrong= which(ratings$date < date.flixster) # 2998
# sum(idx.date.wrong %in% idx.memberfor.wrong) # 35
ratings$date[idx.date.wrong]= date.flixster
dates= ratings$date
```


### Gender
The proportions of the three gender categories previously identified (*Female*, *Male*, and *Other*) were highlighted in a pie chart (see fig. \@ref(fig:pie-chart)).
The set of Flixster's users was comprised of $49\,\%$ of males, $44\,\%$ of females, and $7\,\%$ of other/unidentified genders.

```{r pie-chart, fig.align= "center", fig.height= 4, fig.width= 4, fig.cap= "\\label{pie-chart}Gender spread among Flixster users."}
n.gender= length(gender)
gender.woman= gender[gender == "Female"]
n.woman= length(gender.woman)
gender.woman.pct= round(n.woman / n.gender * 100)
gender.man= gender[gender == "Male"]
n.man= length(gender.man)
gender.man.pct= round(n.man / n.gender * 100)
gender.other= gender[gender == "Other"]
n.other= length(gender.other)
gender.other.pct= round(n.other / n.gender * 100)
gender.labels= c(
  paste('Women:', gender.woman.pct),
  paste('Men:',   gender.man.pct),
  paste('Other:', gender.other.pct))
gender.labels= paste0(gender.labels, '%')
gender.colours= c("#FA9FB5", "#74A9CF", "#2ECC71")
par(mfrow= c(1, 1), oma= c(0, 0, 0, 0))
pie3D(c(n.woman, n.man, n.other), theta= pi/3,
      labels= gender.labels, labelcex= 1.5,
      col= gender.colours,
      start= pi/4, explode= 0.08)
mtext("Gender spread", side= 3, line= -4, outer= T, cex= 2)

```

### Last login
Due to the lack of information about the data set, we do not know exactly what this variable represents.
We suspect, however, it corresponds to the total number of logins during a certain period of time (during the previous month or year) per user.
Assuming that is the case, most of the users had logged in to Flixster during that period of time between approximately 4 to 30 times.
The minimum of `lastlogin` is 0, meaning a user never logged in, and the
maximum is $\num{177278}$.
There are $\num{57925}$ NAs, corresponding to $5.7\,\%$ of all values.
The distribution is strongly right skewed, with several outliers lying far away from the median, *i.e.*, corresponding to number of occurrences several orders of magnitude above the median.
We removed the outliers by wiping out all values with frequencies above 46 (that kept $99\,\%$) of all the values.
The histogram and boxplot of the distribution with and witout outliers are represented in figs. \@ref(fig:lastlogin-out) and \@ref(fig:lastlogin-no-out), respectively.

```{r results= "hide"}
idx.nas.lastlogin= which(is.na(lastlogin)) # 5.7% of all values
lastlogin= na.omit(lastlogin)
var(lastlogin) # 102829.2
skewness(lastlogin) # 217.3447
```

```{r lastlogin-out, fig.cap= "\\label{lastlogin-out}Histogram (*left*) and boxplot (*right*) of the variable `lastlogin`. Some outliers lie very far away from the median."}
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(lastlogin,
  breaks= seq(round(min(lastlogin)) - 1, round(max(lastlogin)) + 1),
  xlab= "Last login"
)
boxplot(lastlogin,
  yaxt= "n",
  main= "Boxplot of lastlogin"
)
axis(2, las= 2)
```
```{r lastlogin-no-out, fig.cap= "\\label{lastlogin-no-out}Histogram (*left*) and boxplot (*right*) of the variable `lastlogin` after removing the outliers."}
### remove outliers
lastlogin.out= boxplot.stats(lastlogin, coef= 20)$out
lastlogin.no.out.idx= !(lastlogin %in% lastlogin.out)
lastlogin.no.out= lastlogin[lastlogin.no.out.idx]
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(lastlogin.no.out,
  breaks= seq(round(min(lastlogin.no.out)) - 1, round(max(lastlogin.no.out))),
  xlab= "Last login",
  main= "Histogram of lastlogin"
)
boxplot(lastlogin.no.out, outline= F, yaxt= "n")
axis(2, las= 2)
mtext(
  side= 3, line= 2, at= 1, cex= 1.2,
  expression(paste("Boxplot of lastlogin"))
)
mtext(side= 3, line= 1, at= 1, cex= 0.7, "Outliers removed")

```

Since this variable did not seem to be relevant for any of our analyses, we decided to discard it.

### Location
This variable presented several NAs, corresponding to $0.02\,\%$ of all values.
The histogram (\@ref(fig:loca-out)) is characterised by a sharp spike at the value 0, with a difference of at least one order of magnitude to the remainder of the local maxima.
This might indicate that 0 corresponds to the most typical region the users belong to, or might be just an indentifier of all users for whom the location is unknown (an outlier, in that case).
Since there is no information about the variables and `location` is a feature of integers, we decided to imput all NAs with the mode (the value 0).
After the imputation, `location` varied between 0 and $\num{1617}$.

```{r}
idx.nas.location= which(is.na(location)) # ~0.02% of all values
loca= na.omit(location)
cat("Variance of `location`:", var(loca)) # 81802.41
cat("Skewness of `location`:", skewness(loca)) # 1.036804
## remove NAs
location[idx.nas.location]= 0
```

```{r loca-out, fig.cap= "\\label{loca-out}Histogram (*left*) and boxplot (*right*) of the `location` variable."}
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(loca,
  breaks= seq(round(min(loca)) - 1, round(max(loca)) + 1),
  xlab= "Location"
)
boxplot(loca,
  yaxt= "n",
  main= "Boxplot of location"
)
axis(2, las= 2)
```

We then looked to the distribution of the `location` values without outliers.
Zero and all values above $\num{1200}$ were placed in this category---the remainder of the set corresponded to approximatelly $99\,\%$ of the original values.
The new histogram and boxplot are represented in fig. \@ref(fig:loca-no-out).

```{r include= F}
remove= c(0)
location= location[!(location %in% remove)]
location.out= boxplot.stats(location)$out
location.no.out.idx= !(location %in% location.out)
location.no.out= location[location.no.out.idx]
```

```{r loca-no-out, fig.cap= "\\label{loca-no-out}Histogram (*left*) and boxplot (*right*) of the `location` variable, after the removal of the outliers."}
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(location.no.out,
  breaks= seq(round(min(location.no.out)) - 1, round(max(location.no.out))),
  xlab= "Location",
  main= "Histogram of location"
)
boxplot(location.no.out, outline= F, yaxt= "n")
axis(2, las= 2)
mtext(
  side= 3, line= 2, at= 1, cex= 1.2,
  expression(paste("Boxplot of location"))
)
mtext(side= 3, line= 1, at= 1, cex= 0.7, "Outliers removed")
```

With outliers removed, we verify that most of the values are between 180 and 300.
However, simillarly to what happeded with `lastlogin`, the lack of information about this feature makes it useless in our analysis.
Therefore, we decided to removed it from the final data set.

### Movie ID
We can find two variables named `movieid` in the data set, one from the `movies` table, and another from the `ratings` table.
The former is composed of unique entries, one per film, while the latter has several instances corresponding to the same movie, one per rating.
That makes `movieid.ratings` larger than `movieid.movies` (respectively $\num{8196077}$ against $\num{66730}$ entries).
None of these variables present NAs.

Since the feature `movieid.movies` represents just the identification (ID) number of each film, there were no relevant statistics to compute.
Hence, we focused our attention in `movieid.ratings` and plotted its histogram (fig. \@ref(fig:movieid)).

```{r movieid, fig.cap= "\\label{movieid}Histogram of the movie ID, contained in the `ratings` tibble. There is a particular film with ID above 60000 with the most of ratings."}

hist(movieid.ratings,
  breaks= seq(round(min(movieid.ratings)) - 1, round(max(movieid.ratings)) + 1),
  xlab= "Movie ID (ratings)"
)
```
From the histogram, we can see that the range of the number of ratings encompasses four orders of magnitude, existing films with much more ratings than others (naturally).
In particular, there is a movie with an ID greater than $\num{60000 }$ with around $\num{35000 }$ ratings that stands out.

### Ratings
Finally, we looked at the `ratings` feature.
From the summary, the histogram, and the boxplot of the variable, we verify that: (*a*) the ratings range between 0.5 and 5.0; (*b*) the most common ratings are 3.0, 3.5, and 5.0; (*c*) the variance is equal to $\num{1.192404}$; and (*d*) the distribution is left skewed ($skew = -0.7054742$).
We were already expecting to find a left skewed distribution for `ratings`, since in a sufficiently large data set of this nature, most of the ratings will lie above the medium (it is expected to find a large number of users liking a substantially large subset of films and, hence, giving them high ratings).
The plots of the histogram and boxplot of `ratings` are illustrated in fig. \@ref(ratings).
```{r}
summary(rating) # min= 0.5; max= 5.0
cat("Variance of `ratings`:", var(rating)) # 1.192404
cat("Skewness of `ratings`:", skewness(rating)) # -0.7054742
```
```{r ratings, fig.cap= "\\label{fig:ratings}Histogram (*left*) and boxplot (*right*) of the `ratings` variable. As expected for this kind of variable (when the data set is sufficiently large), the distribution is left-skewed." }
par(mfrow= c(1, 2), oma= c(0, 2, 3, 1))
hist(rating,
  breaks= seq(round(min(rating)) -0.5, round(max(rating)) +0.5, by= 0.5),
  xlab= "Ratings"
)
boxplot(rating,
  yaxt= "n",
  main= "Boxplot of ratings"
)
axis(2, las= 2)

```

## Data engineering
As mentioned previously, the variables `lastlogin`, `location`, and `memberfor`  were not needed for the context this analysis, and so they were removed (the feature `profileview` had already been removed in the preliminary data analysis).

```{r}
profiles= select(profiles, -c(lastlogin, location, memberfor))
```

The `gender` column in `profiles` was replaced by the updated `gender` standalone variable (including the "Other" gender), and only the instances with no NAs in the age were kept.
At the end, `profiles` was reduced to a $\num{747178} \times 3$ tibble, containing no NAs and with the relevant features `userid`, `gender`, and `age`.
```{r}
profiles$gender= gender
profiles= profiles %>%
  filter(! profiles$age %in% profiles$age[is.na(profiles$age)])
```

We then created two variables, `mean_ratings` and `total_ratings`, respectively corresponding to the average rating by each user and total number of ratings per user.
Those features were added to the `profiles` tibble.

```{r}
user.ratings= ratings %>%
  group_by(userid) %>%
  summarise(
    mean_ratings= mean(rating),
    total_ratings= n()
  )
# join user.ratings with profiles
profiles= left_join(profiles, user.ratings, by= "userid")
## replace NA values in `mean_ratings` and `total_ratings` by 0
profiles= profiles %>%
  mutate(mean_ratings= replace_na(mean_ratings, 0)) %>% 
  mutate(total_ratings= replace_na(total_ratings, 0))
rm(user.ratings)
```

A similar approach was used with the `movies` tibble, where two new columns were created containing the average rating per film (`mean_rating`) and the total number of ratings each movie got (`total_rating`).

```{r}
movie.ratings= ratings %>%
  group_by(movieid) %>%
  summarise(
    mean_ratings= mean(rating),
    total_ratings= n()
  )
## join movie.ratings with movies
movies= left_join(movies, movie.ratings, by= "movieid")
## replace NA values in `mean_ratings` and `total_ratings` with 0
movies= movies %>%
  mutate(mean_ratings= replace_na(mean_ratings, 0)) %>% 
  mutate(total_ratings= replace_na(total_ratings, 0))
rm(movie.ratings)
```

Finally, we joined the three tables into a single tibble named "flixster".
The `ratings` and `profiles` tibbles were joined using the `userid` variable, to which the `movies` tibble was joined using the `movied` feature.

```{r}
flixster= ratings %>%
  left_join(profiles, by= "userid") %>%
  left_join(movies, by= "movieid")

remove(movies, profiles, ratings)
```

A preview of the `flixster` tibble is shown below.
```{r}
flixster
```






We split the dataset in two parts, the training set called `train_set` and the test set called `test_set` with 70% and 30% of the original dataset respectively.

```{r split_dataset, warning=FALSE, error=FALSE}

# 'test_set' will be 30% of dataset
set.seed(1, sample.kind="Rounding")
test_index <- createDataPartition(y = flixster$rating, times = 1, p = 0.3, list = FALSE)

train_set <- flixster[-test_index,]
temp <- flixster[test_index,]

# Make sure userid and movieid in 'test_set' are also in 'train_set'
test_set <- temp %>% semi_join(train_set, by = "movieid") %>% semi_join(train_set, by = "userid")

# Add rows removed from 'test_set' set back into 'train_set' set
removed <- anti_join(temp, test_set)
train_set <- rbind(train_set, removed)

rm(test_index, temp, flixster, removed)

```

## Data Exploration

Before start building the model, we need to understand the structure of the data, the distribution of variables and the relationship of the predictors. This information will help build a better model.

### Profile Data Set











```{r}
glimpse(train_set)
```

From this initial exploration, we can see that `train_set` consists of 5757622 observations spread across 8 variables. The user information are stored in userid, gender, age, range_age columns; the movie information are stored in movieid and moviename columns; the rating information are stored in rating and date columns.   






# References {-}
